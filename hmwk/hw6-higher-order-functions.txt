ex0

map f (filter p xs)

ex1

all p xs = and (map p xs)
all p = and . map p
all p = not . any (not . p) -- lol
all p xs = foldl (&&) True (map p xs)
all p = foldr (&&) True . map p

ex2

any p = or . map p
any p xs = length (filter p xs) > 0
any p = not . null . dropWhile (not . p)
any p xs = not (all (\ x -> not (p x)) xs)
any p xs = foldr (\ x acc -> (p x) || acc) False xs

ex3

takeWhile _ [] = []
takeWhile p (x : xs)
    | p x = x : takeWhile p xs
    | otherwise = []

ex4

dropWhile _ [] = []
dropWhile p (x : xs)
    | p x = dropWhile p xs
    | otherwise = x : xs

ex5

map f = foldl (\ xs x -> xs ++ [f x]) []

ex6

filter p = foldr (\ x xs -> if p x then x : xs else xs) []

ex7

dec2int = foldl (\ x y -> 10 * x + y) 0

ex8

Def of sumsqreven doesn't even typecheck...particularly b/c of the [a -> a] bit

ex9

curry f = \ x y -> f (x, y)

ex10

uncurry f = \ (x, y) -> f x y

ex11